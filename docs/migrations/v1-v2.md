# Гайд по миграции с v1 на v2

## Breaking changes (критичные изменения)

- **Новый основной класс:** Вместо глобального объекта `request` теперь используется класс `HttpClient`.
- **Middleware вместо Interceptors:** В v2 используются middleware с явной типизацией вместо before/after interceptors.
- **Изменён способ создания экземпляра:** Для создания независимых клиентов теперь используется `new HttpClient(...)` вместо `request.create()`.
- **Методы работы с запросами:** Методы теперь доступны только у экземпляра класса, а не глобально.
- **Конфигурация через конструктор:** Базовые параметры (`baseUrl`, `headers`, `middlewares`) передаются в конструктор.
- **Удалён глобальный кэш:** Кэширование реализуется через middleware или вручную.

## Что изменилось

- **API стал объектно-ориентированным:** Все запросы теперь делаются через экземпляр класса, что повышает изоляцию и гибкость.
- **Middleware вместо interceptors:** Middleware позволяют строить цепочки обработки данных с поддержкой строгой типизации.
- **Типизация на уровне всей цепочки:** Благодаря generic-параметрам и функции `defineMiddleware` IDE подсказывает типы на каждом этапе.
- **Метод copy():** Позволяет создавать независимые копии клиента с теми же настройками.
- **Удаление middleware по имени:** Удобно управлять цепочкой обработки.

## Что добавилось

- **Гибкая система middleware:** Можно создавать, регистрировать и удалять middleware с явной типизацией.
- **Метод copy():** Быстрое клонирование клиента для временных изменений.
- **Улучшенная поддержка TypeScript:** Типы теперь прозрачны и для middleware, и для результата запроса.
- **Документация и best practices:** Подробные рекомендации по использованию и расширению клиента.

## Преимущества обновления

- **Безопасность типов:** Меньше ошибок на этапе выполнения, больше подсказок от IDE.
- **Гибкость:** Легко расширять и модифицировать поведение клиента под свои задачи.
- **Изоляция:** Каждый экземпляр клиента независим, удобно для работы с несколькими API или разными конфигами.
- **Современный подход:** Использование middleware — стандарт де-факто для современных HTTP-клиентов.

## Примеры миграции

### Было (v1):

```ts
import { request } from "requestify.js";

request.get("https://api.example.com/users").then((response) => {
  console.log(response.data);
});

// POST с before/after interceptors
request.post("https://api.example.com/users", {
  body: { name: "John" },
  async beforeInterceptor(req) {
    req.headers["Authorization"] = "Bearer ...";
    return req;
  },
  async afterInterceptor(res) {
    return { data: await res.json() };
  },
});
```

### Стало (v2):

```ts
import { HttpClient, defineMiddleware } from "./main";

const authMiddleware = defineMiddleware({
  name: "auth",
  before: async (config) => {
    config.headers = config.headers || {};
    config.headers["Authorization"] = "Bearer ...";
    return config;
  },
});

const jsonMiddleware = defineMiddleware<Response, unknown>({
  name: "json",
  after: async (res) => res.json(),
});

const client = new HttpClient({
  baseUrl: "https://api.example.com",
  middlewares: [authMiddleware, jsonMiddleware],
});

const users = await client.get("/users");
```

## Итоги

- Переход на v2 требует переписать создание клиента и регистрацию обработчиков.
- Взамен вы получаете современный, типобезопасный и гибкий инструмент для работы с HTTP-запросами.
- Вся логика обработки теперь реализуется через middleware, что делает код чище и легче для поддержки.

**Рекомендуется:**

- Использовать middleware для всех кросс-срезных задач (авторизация, логирование, обработка ошибок, преобразование данных и т.д.).
- Для временных изменений или тестов используйте метод `copy()`.
- Всегда явно указывайте типы в defineMiddleware для сложных преобразований.
